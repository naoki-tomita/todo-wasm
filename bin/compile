#!/usr/bin/env bash
BUILD_DIR=${1:-}
CACHE_DIR=${2:-}
ENV_DIR=${3:-}

get_os() {
  uname | tr '[:upper:]' '[:lower:]'
}

get_cpu() {
  if [[ "$(uname -p)" = "i686" ]]; then
    echo "x86"
  else
    echo "x64"
  fi
}

get_platform() {
  os=$(get_os)
  cpu=$(get_cpu)
  echo "$os-$cpu"
}

create_default_env() {
  export NPM_CONFIG_LOGLEVEL=${NPM_CONFIG_LOGLEVEL:-error}
  export NODE_MODULES_CACHE=${NODE_MODULES_CACHE:-true}
  export NODE_ENV=${NODE_ENV:-production}
  export NODE_VERBOSE=${NODE_VERBOSE:-false}
}

create_build_env() {
  # if the user hasn't set NODE_OPTIONS, increase the default amount of space
  # that a node process can address to match that of the build dynos (2.5GB)
  if [[ -z $NODE_OPTIONS ]]; then
    export NODE_OPTIONS="--max_old_space_size=2560"
  fi
}

list_node_config() {
  echo ""
  printenv | grep ^NPM_CONFIG_ || true
  printenv | grep ^YARN_ || true
  printenv | grep ^NODE_ || true

  if [ "$NPM_CONFIG_PRODUCTION" = "true" ] && [ "$NODE_ENV" != "production" ]; then
    echo ""
    echo "npm scripts will see NODE_ENV=production (not '${NODE_ENV}')"
    echo "https://docs.npmjs.com/misc/config#production"
  fi

  if [ "$NPM_CONFIG_PRODUCTION" == "true" ]; then
    mcount "npm-config-production-true"
  elif [ "$NPM_CONFIG_PRODUCTION" == "false" ]; then
    mcount "npm-config-production-false"
  fi
}

export_env_dir() {
  local env_dir=$1
  if [ -d "$env_dir" ]; then
    local whitelist_regex=${2:-''}
    local blacklist_regex=${3:-'^(PATH|GIT_DIR|CPATH|CPPATH|LD_PRELOAD|LIBRARY_PATH|LANG|BUILD_DIR)$'}
    # shellcheck disable=SC2164
    pushd "$env_dir" >/dev/null
    for e in *; do
      [ -e "$e" ] || continue
      echo "$e" | grep -E "$whitelist_regex" | grep -qvE "$blacklist_regex" &&
      export "$e=$(cat "$e")"
      :
    done
    # shellcheck disable=SC2164
    popd >/dev/null
  fi
}

write_profile() {
  local bp_dir="$1"
  local build_dir="$2"
  mkdir -p "$build_dir/.profile.d"
  cp "$bp_dir"/profile/* "$build_dir/.profile.d/"
}

write_ci_profile() {
  local bp_dir="$1"
  local build_dir="$2"
  write_profile "$1" "$2"
  cp "$bp_dir"/ci-profile/* "$build_dir/.profile.d/"
}

write_export() {
  local bp_dir="$1"
  local build_dir="$2"

  # only write the export script if the buildpack directory is writable.
  # this may occur in situations outside of Heroku, such as running the
  # buildpacks locally.
  if [ -w "$bp_dir" ]; then
    echo "export PATH=\"$build_dir/.heroku/node/bin:$build_dir/.heroku/yarn/bin:\$PATH:$build_dir/node_modules/.bin\"" > "$bp_dir/export"
    echo "export NODE_HOME=\"$build_dir/.heroku/node\"" >> "$bp_dir/export"
  fi
}

resolve() {
  local binary="$1"
  local versionRequirement="$2"
  local n=0
  local output

  # retry this up to 5 times in case of spurious failed API requests
  until [ $n -ge 5 ]
  do
    # if a user sets the HTTP_PROXY ENV var, it could prevent this from making the S3 requests
    # it needs here. We can ignore this proxy for aws urls with NO_PROXY. Some environments
    # require a proxy for all HTTP requests, so the NO_PROXY ENV var should be set outside the
    # script by the user
    # see testAvoidHttpProxyVersionResolutionIssue test and README
    if output=$($RESOLVE "$binary" "$versionRequirement"); then
      echo "$output"
      return 0
    # don't retry if we get a negative result
    elif [[ $output = "No result" ]]; then
      return 1
    elif [[ $output == "Could not parse"* ]] || [[ $output == "Could not get"* ]]; then
      return 1
    else
      n=$((n+1))
      # break for a second with a linear backoff
      sleep $((n+1))
    fi
  done

  return 1
}


install_nodejs() {
  local version=${1:-12.x}
  local dir="${2:?}"
  local code os cpu resolve_result

  os=$(get_os)
  cpu=$(get_cpu)

  echo "Resolving node version $version..."
  resolve_result=$(resolve node "$version" || echo "failed")

  read -r number url < <(echo "$resolve_result")

  if [[ "$resolve_result" == "failed" ]]; then
    fail_bin_install node "$version"
  fi

  echo "Downloading and installing node $number..."
  code=$(curl "$url" -L --silent --fail --retry 5 --retry-max-time 15 -o /tmp/node.tar.gz --write-out "%{http_code}")
  if [ "$code" != "200" ]; then
    echo "Unable to download node: $code" && false
  fi
  tar xzf /tmp/node.tar.gz -C /tmp
  rm -rf "${dir:?}"/*
  mv /tmp/node-v"$number"-"$os"-"$cpu"/* "$dir"
  chmod +x "$dir"/bin/*
}

install_npm() {
  local npm_version
  local version="$1"
  local dir="$2"
  local npm_lock="$3"
  npm_version="$(npm --version)"

  # If the user has not specified a version of npm, but has an npm lockfile
  # upgrade them to npm 5.x if a suitable version was not installed with Node
  if $npm_lock && [ "$version" == "" ] && [ "${npm_version:0:1}" -lt "5" ]; then
    echo "Detected package-lock.json: defaulting npm to version 5.x.x"
    version="5.x.x"
  fi

  if [ "$version" == "" ]; then
    echo "Using default npm version: $npm_version"
  elif [[ "$npm_version" == "$version" ]]; then
    echo "npm $npm_version already installed with node"
  else
    echo "Bootstrapping npm $version (replacing $npm_version)..."
    if ! npm install --unsafe-perm --quiet -g "npm@$version" 2>@1>/dev/null; then
      echo "Unable to install npm $version; does it exist?" && false
    fi
    echo "npm $version installed"
  fi
}


export PATH="$HOME/.heroku/node/bin:$HOME/.heroku/yarn/bin:$PATH:$HOME/bin:$HOME/node_modules/.bin"
export NODE_HOME="$HOME/.heroku/node"
export NODE_ENV=${NODE_ENV:-production}

# Switch to our cache directory.
mkdir -p "$CACHE_DIR"
cd "$CACHE_DIR"

BP_DIR=$(cd $(dirname ${0:-}); cd ..; pwd)
cat <<EOF > $BP_DIR/export
# Our rustup installation.
export RUSTUP_HOME="$CACHE_DIR/multirust"
# Our cargo installation.  We implicitly trust Rustup and Cargo
# to do the right thing when new versions are released.
export CARGO_HOME="$CACHE_DIR/cargo"
# Include binaries installed by cargo and rustup in our path.
PATH="\$CARGO_HOME/bin:\$PATH"
EOF
. $BP_DIR/export

echo "-----> Setup for rust environment"
if [ -d "$CARGO_HOME" ]; then
    echo "-----> Checking for new releases of Rust nightly channel"
    # It's possible that $VERSION has changed, or the `stable` channel has updated.
    rustup self update
    rustup update nightly
    rustup default nightly
else
    echo "-----> Downloading rustup"
    curl https://sh.rustup.rs -sSf > rustup.sh
    chmod u+x rustup.sh
    echo "-----> Using rustup to install Rust channel $VERSION"
    ./rustup.sh -y --default-toolchain nightly
    rm rustup.sh
fi
if [ ! -x "$CARGO_HOME/bin/rustc" ]; then
  echo "failed: Cannot find Rust binaries at $CARGO_HOME"
  exit 1
fi

if [ ! -x "cargo web -V" ]; then
  cargo install cargo-web
fi


# This is where we will cache our Rust output.  Note the suggestions at
# https://github.com/alexcrichton/cargo/commit/014765f788ca1c2476936835ca32cc2746f99b42
# which describe how this needs to be named.
export CARGO_TARGET_DIR="$CACHE_DIR/target"

echo "-----> Building SERVER application using Cargo"
cd $BUILD_DIR/server
cargo build --release
mkdir -p target/release
cp $CARGO_TARGET_DIR/release/server target/release

echo "-----> Building FRONT application using Cargo"
cd $BUILD_DIR/full-app
cargo web deploy
mkdir -p target/deploy
cp -r $CARGO_TARGET_DIR/deploy/* target/deploy

mkdir -p $BUILD_DIR/.heroku/node
install_nodejs 12.x $BUILD_DIR/.heroku/node
# mkdir -p $BUILD_DIR/.heroku/npm
# install_npm 6 $BUILD_DIR/.heroku/node false
